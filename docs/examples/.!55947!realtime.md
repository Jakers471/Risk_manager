# Real-time Data Processing Examples

This page demonstrates how to work with real-time market data streams using the ProjectX Python SDK v3.3.4. Learn to handle WebSocket data, process multiple timeframes, and build real-time trading systems.

## Prerequisites

- ProjectX API credentials with real-time data access
- Active market during testing (futures trading hours)
- Understanding of async/await patterns
- Basic knowledge of market data structures

## 1. Basic Real-time Data Streaming

Start with simple real-time data consumption:

```python
#!/usr/bin/env python
"""
Basic real-time data streaming example
"""
import asyncio
from datetime import datetime
from project_x_py import TradingSuite, EventType

async def main():
    # Create suite with real-time capabilities
    suite = await TradingSuite.create(
        "MNQ",
        timeframes=["15sec", "1min"],
        initial_days=1  # Minimal historical data
    )

    print(f"Real-time streaming started for {suite.instrument}")
    print(f"Connected: {suite.is_connected}")

    # Track statistics
    tick_count = 0
    bar_count = 0
    last_price = None

    async def on_tick(event):
        nonlocal tick_count, last_price
        tick_data = event.data

        tick_count += 1
        last_price = tick_data.get('price', 0)

        # Display every 10th tick to avoid spam
        if tick_count % 10 == 0:
            timestamp = datetime.now().strftime("%H:%M:%S")
            print(f"[{timestamp}] Tick #{tick_count}: ${last_price:.2f}")

    async def on_new_bar(event):
        nonlocal bar_count
        bar_data = event.data
        bar_count += 1

        timestamp = datetime.now().strftime("%H:%M:%S")
        timeframe = bar_data.get('timeframe', 'unknown')

        print(f"[{timestamp}] New {timeframe} bar #{bar_count}:")
        print(f"  OHLC: ${bar_data['open']:.2f} / ${bar_data['high']:.2f} / ${bar_data['low']:.2f} / ${bar_data['close']:.2f}")
        print(f"  Volume: {bar_data.get('volume', 0)}")
        print(f"  Timestamp: {bar_data.get('timestamp')}")

    async def on_connection_status(event):
        status = event.data.get('status', 'unknown')
        print(f"Connection Status: {status}")

    # Register event handlers
    await suite.on(EventType.TICK, on_tick)
    await suite.on(EventType.NEW_BAR, on_new_bar)
    await suite.on(EventType.CONNECTION_STATUS, on_connection_status)

    print("Listening for real-time data... Press Ctrl+C to exit")

    try:
        while True:
            await asyncio.sleep(10)

            # Display periodic status
            current_price = await suite.data.get_current_price()
            connection_health = await suite.data.get_connection_health()

            print(f"Status - Price: ${current_price:.2f} | Ticks: {tick_count} | Bars: {bar_count} | Health: {connection_health}")

    except KeyboardInterrupt:
        print("\nShutting down real-time stream...")

if __name__ == "__main__":
    asyncio.run(main())
```

## 2. Multi-Timeframe Data Synchronization

Handle multiple timeframes with proper synchronization:

```python
#!/usr/bin/env python
"""
Multi-timeframe real-time data synchronization
"""
import asyncio
from collections import defaultdict
from datetime import datetime
from project_x_py import TradingSuite, EventType
from project_x_py.indicators import SMA, RSI

class MultiTimeframeDataProcessor:
    def __init__(self, suite: TradingSuite):
        self.suite = suite
        self.timeframes = ["1min", "5min", "15min"]
        self.data_cache = defaultdict(list)
        self.last_analysis = defaultdict(dict)
        self.analysis_count = 0

    async def process_new_bar(self, event):
        """Process incoming bar data for all timeframes."""
        bar_data = event.data
        timeframe = bar_data.get('timeframe', 'unknown')

        if timeframe not in self.timeframes:
            return

        # Store the bar
        self.data_cache[timeframe].append(bar_data)

        # Keep only recent bars (memory management)
        if len(self.data_cache[timeframe]) > 200:
            self.data_cache[timeframe] = self.data_cache[timeframe][-100:]

        print(f"New {timeframe} bar: ${bar_data['close']:.2f} @ {bar_data.get('timestamp')}")

        # Perform analysis on this timeframe
        await self.analyze_timeframe(timeframe)

        # Check for multi-timeframe confluence
        if timeframe == "1min":  # Trigger confluence check on fastest timeframe
            await self.check_confluence()

    async def analyze_timeframe(self, timeframe: str):
        """Analyze a specific timeframe with technical indicators."""
        try:
            # Get fresh data from suite
            bars = await self.suite.data.get_data(timeframe)

            if len(bars) < 50:  # Need enough data for indicators
                return

            # Calculate indicators
            sma_20 = bars.pipe(SMA, period=20)
            rsi = bars.pipe(RSI, period=14)

            current_price = bars['close'][-1]
            current_sma = sma_20[-1]
            current_rsi = rsi[-1]

            # Determine trend and momentum
            trend = "bullish" if current_price > current_sma else "bearish"
            momentum = "strong" if (trend == "bullish" and current_rsi > 50) or (trend == "bearish" and current_rsi < 50) else "weak"

            # Store analysis
            self.last_analysis[timeframe] = {
                "price": current_price,
                "sma_20": current_sma,
                "rsi": current_rsi,
                "trend": trend,
                "momentum": momentum,
                "timestamp": datetime.now()
            }

            print(f"  {timeframe} Analysis - Trend: {trend}, RSI: {current_rsi:.1f}, Momentum: {momentum}")

        except Exception as e:
            print(f"Error analyzing {timeframe}: {e}")

    async def check_confluence(self):
        """Check for confluence across all timeframes."""
        self.analysis_count += 1

        # Only check confluence every 5th analysis to avoid spam
        if self.analysis_count % 5 != 0:
            return

        if len(self.last_analysis) < len(self.timeframes):
            return

        # Count bullish/bearish signals
        bullish_count = sum(1 for analysis in self.last_analysis.values()
                           if analysis.get('trend') == 'bullish')
        bearish_count = sum(1 for analysis in self.last_analysis.values()
                           if analysis.get('trend') == 'bearish')

        # Check for strong confluence
        total_timeframes = len(self.last_analysis)

        if bullish_count >= total_timeframes * 0.8:  # 80% agreement
