# Real-time Data Guide

This guide covers comprehensive real-time data streaming using ProjectX Python SDK v3.3.4+. All real-time operations are fully asynchronous and provide high-performance WebSocket connectivity with automatic reconnection and memory management.

## Overview

The RealtimeDataManager provides complete real-time market data streaming including OHLCV bars, tick data, price updates, and multi-timeframe synchronization. All operations are designed for high-frequency trading applications with minimal latency.

### Key Features

- **Multi-timeframe Streaming**: Simultaneous data across multiple timeframes
- **WebSocket Connectivity**: High-performance async WebSocket connections
- **Automatic Reconnection**: Built-in circuit breaker and reconnection logic
- **Memory Management**: Sliding windows with automatic cleanup
- **Event-Driven Architecture**: Real-time callbacks for all data updates
- **Data Synchronization**: Synchronized updates across timeframes
- **Performance Optimization**: Connection pooling and message batching

## Getting Started

### Basic Real-time Setup

```python
import asyncio
from project_x_py import TradingSuite, EventType

async def basic_realtime_setup():
    # Initialize with real-time capabilities
    suite = await TradingSuite.create(
        "MNQ",
        timeframes=["1sec", "1min", "5min"],  # Multiple timeframes
        initial_days=2  # Historical data for context
    )

    # Real-time data manager is automatically initialized and connected
    data_manager = suite.data

    print("Real-time connection established!")

    # Get current price
    current_price = await data_manager.get_current_price()
    print(f"Current MNQ price: ${current_price}")

    # Get recent data
    recent_1min = await data_manager.get_data("1min", bars=10)
    print(f"Last 10 1-minute bars: {len(recent_1min)} rows")
```

### Connection Management

The TradingSuite automatically manages WebSocket connections, but you can monitor and control them:

```python
async def connection_management():
    suite = await TradingSuite.create("MNQ")

    # Check connection status
    connection_status = await suite.data.get_connection_status()
    print(f"Connection Status: {connection_status}")

    # Connection health monitoring
    health = await suite.data.get_connection_health()
    print(f"Connection Health:")
    print(f"  Status: {health['status']}")
    print(f"  Uptime: {health['uptime']}")
    print(f"  Messages Received: {health['messages_received']}")
    print(f"  Last Message: {health['last_message_time']}")

    # Manual reconnection (rarely needed)
    if health['status'] != 'CONNECTED':
        print("Reconnecting...")
        await suite.data.reconnect()
```

## Real-time Data Types

### Price Ticks

Real-time price updates provide the most granular market data:

```python
async def handle_price_ticks():
    suite = await TradingSuite.create("MNQ")

    # Event-driven tick handling
    async def on_tick(event):
        tick_data = event.data

        print(f"Tick: ${tick_data['price']} (Size: {tick_data['size']})")
        print(f"  Time: {tick_data['timestamp']}")
        print(f"  Bid/Ask: ${tick_data['bid']}/${tick_data['ask']}")

        # Tick analysis
        if tick_data['size'] > 50:  # Large tick
            print(f"  =% Large tick detected!")

    # Register tick handler
    await suite.on(EventType.TICK_UPDATE, on_tick)

    # Alternative: Callback-based approach
    async def tick_callback(tick_data):
        print(f"Callback tick: ${tick_data['price']}")

    await suite.data.add_callback("tick", tick_callback)

    # Stream ticks for 30 seconds
    print("Streaming ticks...")
    await asyncio.sleep(30)
```

### OHLCV Bars

Real-time bar formation across multiple timeframes:

```python
async def handle_bar_updates():
    suite = await TradingSuite.create(
        "MNQ",
        timeframes=["15sec", "1min", "5min", "15min"]
    )

    # Bar update handler
    async def on_new_bar(event):
        bar_data = event.data
        timeframe = bar_data['timeframe']
        bar = bar_data['data']

        print(f"New {timeframe} bar:")
        print(f"  O: ${bar['open']} H: ${bar['high']}")
        print(f"  L: ${bar['low']} C: ${bar['close']}")
        print(f"  Volume: {bar['volume']}")
        print(f"  Time: {bar['timestamp']}")

        # Bar analysis
        body_size = abs(bar['close'] - bar['open'])
        range_size = bar['high'] - bar['low']

        if body_size > range_size * 0.8:  # Strong directional bar
            direction = "Bullish" if bar['close'] > bar['open'] else "Bearish"
